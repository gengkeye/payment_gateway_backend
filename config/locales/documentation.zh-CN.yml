zh-CN:
  documentation:
    title: '开发者文档'
    introduction:
      title: "简介"
      paragraph1: "本文档主要的面向是希望将比特币支付处理集成到其在线商店或网站中的开发人员。如果您不是开发人员，但仍希望在您的网站上接受Bitcoin，则可以使用我们的分步指南创建一个简单的付款小插件。"
      paragraph2: "根据行业标准处理付款，如果您曾经处理过任何支付网关（不一定是Bitcoin），您应该快速了解一切如何正常工作以及该做什么对于那些从未从事付款处理的人员，我们将会解释每一个细节，并展示代码示例。"
      paragraph3: "Skyluster使用开源软件构建直向和直向服务器。您可以需要检查直向服务器的文档，以便更好地了解底层机制，但不是必需的。在直向服务器文档中提到的许多事情也在当前文档中提到。"
    overview_payment_process:
      title: '支付网关概述'
      paragraph1: "本节介绍有关付款处理的一些基本信息，并介绍将在以下部分中使用的术语。这里描述的一些事情对于所有支付处理器是常见的，而其他的可能不是。阅读本节后，您应该对Skyluster如何运作有一个很好的了解，并且可以继续下一节。"
      paragraph2: "支付网关用于处理您的付款 - 例如收取信用卡，然后在付款完成后将其报告回您的平台或网上商店。当用户点击您网站上的“付款”时，您将其重定向到付款处理器网站上的特殊付款页面，以便他们输入信用卡信息并付款。然后，当他们完成（或取消）付款时，支付处理器可以通过回调（有时称为webhook）让您的网站知道，并通过向您的网站发出http请求来传输关于付款的信息。那么您的网站有义务接收该信息并处理它。"
      paragraph3: "例如，假设您有一个名为worldsbestshoes.com的网站，通过信用卡付款处理器VeryPay.com接受付款。用户选择他的鞋子，将其添加到网站上的\"购物车\"，然后点击“完成购买”。在这一点上，你把他重定向到："
      paragraph4: "在那里，用户看到可以输入他的信用卡信息的表单。一旦他完成输入，他点击“付款”。一旦他这样做，VeryPay连接到他的信用卡公司的API，并试图收取卡。如果操作成功，它将用户重定向回您的网站（或向他显示将手动重定向到他的按钮），并发出回调（webhook）到:"
      paragraph5: "它通过POST参数发送所有关于付款的信息。如果付款失败，它可以让客户知道，并且还会在您的网站上发回同一个网址的回拨，但这次付款信息包含有关付款失败的信息。"
      paragraph6: "然后，您的网站会收到付款信息，根据是否可行，决定要做什么。如果付款通过，它将自己的数据库中的订单标记为已付款，然后您的运输部门可以开始包装鞋子。或者它可能会将其标记为“付款失败”，在这种情况下，您可能希望为客户提供使用其他信用卡再次尝试的选项。"
      paragraph7: "所描述的过程几乎与比特币付款相同。唯一的区别是，客户不需要提供任何敏感信息，如信用卡号码。相反，在付款页面上，他看到一个比特币地址（都是写入和作为二维码），然后可以使用他的钱包向该地址汇款。然后，付款处理器的工作是检测到付款，通知商家，并将客户重定向到平台站点。这正是Skyluster所做的。"
      paragraph8: "重要的问题是：付款时，钱在哪里？传统上，使用信用卡付款处理器，这笔钱首先从客户的银行帐户转到支付处理商的银行帐户，然后才转到商家。该系统的问题是付款处理器必须代表许多不同的商家接受和暂时存储货币，并且非常有信心保护该货币的能力。另一方面，商家必须愿意相信付款处理器。幸运的是，使用比特币，您可以解除货币存储和付款处理。使用BIP32，Skyluster可以从您从Bitcoin钱包（机密或Electrum）获得的每个付款发票上的公钥生成一个新地址。这样一来，客户支付的钱总是直接从客户的钱包进入商家的钱包，而支付处理器只是看着區块链，并检查该特定地址是否接收到比特币。商家不必相信他们的付款处理器，并且不会冒失去代表他们所持有的资金的风险，商家处理器不必担心与安全存储货币和客户数据相关的成本。"
      paragraph9: "因此，最好将“skyluster”视为付款通知系统而不是支付处理器。我们只看着这块块，我们实际上并不拥有任何人的钱。"
      paragraph10: "接下来的部分将详细说明如何将支付处理集成到您的网站或应用程序中。但是，首先熟悉将要使用的术语是一个好主意。"
      paragraph_title1: "为什么需要付款处理器？"
      paragraph_title2: "付款处理器通常如何工作？"
      paragraph_title3: "比特币支付处理如何不同？"
      paragraph_title4: "处理钱"
      paragraph_title5: "术语"
      li:
        strong1: "付款处理器"
        strong2: "网关"
        strong3: "订单"
        strong4: "回调"
        description1: "是一种专门的软件或服务，集成到您的网站，并在付款时通知它。对于比特币支付处理，skyluster负责汇率转换，各种比特币面额，生成新的比特币地址以及监控支付方式。请注意，有时支付处理器也称为支付网关。这些术语是同义词，但是在我们的术语中的一个门户将具有稍微更具体的含义。"
        description2: "是在skyluster中创建的一个实例，用于处理特定商店的所有付款。例如，您作为商家可能有两家网上商店。然后，您将在商戶管理面板中创建两个网关，并将其用于各自的网站。" 
        description3: "每次客户决定付款时都会创建一个订单。订单是一个数据集，其中包含诸如要支付的金额，付款将被发送的比特币地址等信息，以及许多其他信息。每个订单都存储在我们的数据库中，并与特定的网关和商家相关联。订单也有可能改变的状态。例如，当相关联的比特币地址接收到正确的数量时，设置“付费”状态。" 
        description4: "是一个http请求，只要订单更改其状态，就由付款处理器发出。每个网关允许您设置发出此请求的URL。您必须编程您的网站，以便它可以处理此请求，提取必要的信息，并正确使用它。" 
    create_gateway:
      title: "创建一个网关"
      paragraph1: "您注册后首先要做的（当然，阅读文档）是创建一个新的网关。网关是为特定平台创建订单和处理付款的实体。所以，如果你只有一个在线平台，你将需要创建一个网关。"
      paragraph2: "要创建网关，只需转到此页面并填写表单。几乎所有的字段都是可选的，并在下面解释（必填字段标有星号*）。"
      paragraph3: "*名称是您的客户在付款页面的顶部尝试购买时会看到的。它也是您在管理面板中作为商家看到的网关的名称。虽然它不会特别影响任何东西，但最好把一些有意义的东西放在那里。通常，确认需要设置为0，除非您预期付款金额很大。在比特币，只有当您有6次确认（可能需要大约一个小时）时，每笔交易才被视为完全解决。但是，您仍然可以承担一定程度的确定，一旦交易已经被广播到比特币网络，支付将在一小时内得到处理和结算。您通常不希望您的客户等待，因此目前的行业标准是接受0个确认交易。这样一旦你的客户从他的钱包里发货，就可以检测到这笔交易，并将他重定向到你的网站。"
      paragraph4: "BIP32 pubkey是最重要的字段，看起来与此类似（以xpub开头）："
      paragraph5: "它是基于Bitcoin BIP32标准，并从您的钱包的私钥派生出来。菌丝机构使用它为每个新订单生成新的地址。不是所有的钱包都支持BIP32，而是最受欢迎的两种開源碼-Mycelium和Electrum。"
      paragraph6: "订单到期期间是客户必须支付订单的时间段。如果他不及时付款，该订单被视为已过期。默认值为900秒（15分钟），这是行业标准"
      paragraph7: "付款重定向网址用于在成功购买后将客户退回您的网站。这可能是一个专门针对该订单或其帐户的页面。"
      paragraph8: "勾选自动重定向功能后，所有付款成功的用户都会自动重定向到「付款后重定向网址」。"
      paragraph9: "活动标志只意味着此网关目前准备好处理付款。如果您需要暂时停止接受付款，您可以随时返回该表单（编辑现有网关），并取消选中该复选框。"
      paragraph10: "货币转换选项部分允许您选择显示订单价格的货币，以及用于将该价值转换为适当数量的比特币的哪个比特币价格来源。默认设置为美元，您可能希望以这种方式离开，因为比特币汇率可能会大幅波动，使得在BTC中设定价格变得不方便。汇率提供者字段允许您选择要用于当前汇率的哪些来源。汇率按照此处设定的顺序进行检查，随后的提供者只会检查以前的提供者是否因某些原因不可用。"
      paragraph11: "关于商业区块的附加信息是完全可选的，但是我们更喜欢商家填写，因为这将有助于我们为客户提供更好的服务。此信息不适用于合规性 - skyluster不处理任何资金（仅观看块上的交易），不受AML / KYC的约束 - 我们不会与任何人共享此信息。"
      paragraph12: "单击表单下面的“创建网关”按钮后，如果所有字段都有效，您将被重定向到网关信息页面，并显示网关密钥。你必须写下来，因为它不会再出现在任何地方。如果你失去了这个秘密，你将需要回到那个表格（编辑网关）并检查“再生秘密”复选框;然而，这将使您以前的秘密无效，并且正在使用它的任何在线商店必须将其更新为新的。"
      paragraph13: "秘密密钥本质上是您对网关的所有请求都签名的签名，网关用于验证您是否正在与其通话，而不是一些冒名顶替者。我们将在下一节中详细介绍如何使用这个密钥。"
      paragraph_title1: "填充表单"
      paragraph_title2: "获取网关私钥"
    api:
      title: "API"
      signed_request:
        title: "请求加密"
        paragraph1: "对API的大多数请求需要一个保护网关免受未经授权访问的签名。签名是一个具有约88个字符的字符串的X签名HTTP标头："
        paragraph2: "注解："
        paragraph3: "Ruby用户可以使用gem straight-server-kit来签名。"
        paragraph4: "由于同时签名的请求具有较大的随机数，因此“X-Nonce无效“错误的请求将失败。 这可以通过用更新的随机数和签名重复请求来缓解。"
        paragraph5: "像JavaScript这样的语言对二进制字符串的支持很差，所以十六进制签名也是有效的。"
        paragraph6: "注解："
        paragraph7: "示例 1:"
        paragraph8: "示例 2:"
        paragraph9: "示例 3:"
        ul:
          li1: "REQUEST_METHOD: 请求方法，如'GET', 'POST'等。"
          li2: "REQUEST_URI: 请求的URI，“/full/path/with?arguments&amp;and#fragment”, 不包含主机名。"
          li3: "REQUEST_BODY: 最终的请求Body，可以是json数据，也可以为空字符串。"
          li4: "X-Nonce: HTTP请求的头部，是一个整数，这个整数必须是随着请求数增加而增加的，这样可以阻止延迟攻击。Ruby用户可以使用(Time.now.to_f * 1000).to_i"
          li5: "SHA512: 二进制 SHA-2, 512 bits"
          li6: "HMAC-SHA512: 二进制的 HMAC-SHA512"
          li7: "GATEWAY_SECRET: HMAC的key"
          li8: "Base64StrictEncode: 根据RFC 4648编码的Base64。"
          li9: "SHA512: 二进制 SHA-2, 512 bits"
          li10: "HMAC-SHA512: 二进制的HMAC-SHA512"
      create_orders:
        title: "创建订单"
        paragraph1: "创建订单是接受付款的第一步。 一般来说，您要在客户点击“完成购买”或在线商店中的类似按钮后创建订单。 使用我们的RESTFUL API创建订单后，您可以将用户重定向到与此订单相关联的管理系统支付页面。"
        paragraph2: "要创建订单，您应该向https://gateway.gear.mycelium.com/gateways/:gateway_id/orders发出签名的POST请求，其中至少有一个参数 - 它决定了为此订单支付的金额。 金额应该是您以前为网关设置的货币。 如果网关货币是BTC，那么数量通常是satoshis。 因此，请求可能如下所示："
        paragraph3: "您可以从管理面板中的网关信息获取api_gateway_id值。"
        paragraph4: "Keychain id用于生成下一个订单的地址。 它可以是任何大于0的整数，但是如果它是一个连续的整数，则更好，因此请在应用程序中跟踪您的订单ID。 使用钥匙串ID，请求将如下所示："
        paragraph5: "您可能希望发送一些额外的数据，该事务将在回调中随后返回给您，不改变。 如果您希望通过使用除order_id之外的其他内容来识别DB中哪个记录与哪个订单相关联，那么此功能非常有用。"
        paragraph6: "例如，假设您的Rails应用程序中有购买模型。 然后，您可能需要创建一个购买并将其id发送到callback_data参数："
        paragraph7: "之后，当发出一个回调请求时，这个callback_data参数将被返回，您将可以在DB中找到该訂單。"
        paragraph8: "根据上述要求，您将收到以下来自skyluster的json："
        paragraph9: "有了这些信息，您可以手动将付款地址显示在您网站上的客户（因此他甚至不必离开您的网站），或者您可以使用payment_id将他重定向到skyluster支付页面。 然后，付款页面的重定向网址将是："
        paragraph10: "keychain_id用于从您的BIP32 pubkey生成下一个地址。如果您尝试使用相同的keychain_id创建订单，它们也将具有相同的地址，这是您可以想象的，这不是一个好主意。然而，这是允许的，有一个很好的理由。"
        paragraph11: "支持BIP32 pubkey的钱包只能对有限数量的地址进行转发地址查找。例如，如果您有20个过期的未付款订单和有人将您的钱送到21-st订单的地址，您的钱包可能看不到。因此，重要的是确保连续不超过20个过期订单。"
        paragraph12: "如果您连续20个订单，并尝试创建另一个订单，Gear将会看到，并将自动重新使用第20个订单的keychain_id（也就是地址）。它还将21阶订单的重用字段设置为1的值。您将在管理面板中看到它被标记为重用。"
        paragraph13: "小心：确保您不会意外提供距离上次使用的keychain_id太远的keychain_id是非常重要的。例如，如果网关的last_keychain_id为10，则不要对下一个订单使用35，请使用11.当您创建或检查订单状态时，last_keychain_id始终与其他信息一起返回。确保您始终跟踪应用程序中的last_keychain_id - 当您创建或检查订单时，通常会在json中返回给您其他订单信息。"
        paragraph14: "假设您有一个名为complete_purchase的操作的Rails控制器，当您的站点上的“完成购买”按钮处理客户请求时，它将处理客户请求。 这是什么代码可能看起来像："
        paragraph_title1: "请求和签名"
        paragraph_title2: "发送附加数据"
        paragraph_title3: "返回结果"
        paragraph_title4: "地址重用和keychain_id"
        paragraph_title5: "代码示例"
      receive_order_callback:
        title: "接收订单状态变更回调"
        paragraph1: "每当订单状态发生变化时，Skyluster会向网关的回调字段（如果已填写）中指定的URL或订单的callback_url参数发出GET http请求。 这样一来，您的网站就会知道付款是成功的，或由于某种原因而失败。 这个http请求有时也被称为webhook，尽管我们不喜欢使用该术语。"
        paragraph2: "重要信息在此http请求中作为url参数传递。 这是一个典型的回调可能是这样的："
        paragraph3: "另外请求会有特殊的标题："
        paragraph4: "以下列表详细说明了GET回调请求中的信息和参数："
        paragraph5: "它以与签名的API请求的签名相同的方式生成，除了它使用空白的Nonce和Body。"
        paragraph6: "在Ruby中，回调签名可以使用直接服务器套件进行验证。"
        paragraph7: "签名验证细节。"
        paragraph8: "JavaScript版本"
        paragraph_title1: "回调签名"
        ul:
          li1: "订单内部ID。你需要用这个ID来对应你自己数据库中的订单。它也被用于签名。"
          li2: "需要被支付的网关货币金额。"
          li3: "需要被支付的比特比金额。"
          li4: "已经被支付的比特比金额。"
          li5: "返回一个数字类型的值，如以下值："
          li6: "未被确认的。交易被接收，但还没有得到足够的确认。"
          li7: "完成支付。"
          li8: "只支付了一部分。没有收到足够的钱。"
          li9: "超额支付。收到的钱多于订单金额。"
          li10: "过期的。客户没有规定时间内支付。"
          li11: "取消的。客户自己取消了该订单。"
          li12: "用于交易的比特币地址。"
          li13: "如果状态值是1、2、3或4，这将包含含有比特币交易IDs的JSON数组。"
          li14: "这包含了任何创建订单时所发送的附加信息。例如，如果你在创建订单时添加了附加数据“Hello Ruby”，那么你将会从回调中得到相同的字符串“Hello Ruby”，因为这个值存于返回结果的json中。"
          li15: " 对于安全来讲，这是最重要的信息之一。记住，任何人都可以向你的这个回调URL发起请求，来欺骗你的网站，使你认为一个特定的订单是已被支付。为了避免这样的情况发生，skyluster使用签名来加密一个回调请求，因此你可以检查它是否来自我们的网站。下面会详细解释。"

      check_order_status:
        title: "手动查询订单状态"
        paragraph1: "虽然通过回调通知是让您的网站知道订单状态已更改的标准方式，但有时可能还不够。 例如，您的网站可能已关闭，可能无法在发出回执时处理回调。 即使skyluser仍会继续尝试发布新的回拨请求，尝试访问您的网站，但它只会持续一个小时，之后才会退出。"
        paragraph2: "因此，重要的是要有其他可靠的检查订单状态的方法。 要查看订单的当前状态，请发出以下签名的GET请求："
        paragraph3: "其中：api_gateway_id是您的网关的API标识，您可以查看其信息页面; 和：payment_id是您确定订单的方式（最初在创建订单时返回给您）。 响应将返回一个类似于通过参数传递给你的回调的json："
        paragraph4: "只有当您怀疑您可能错过了回拨时，才应使用本手册。 每隔几秒钟不断查询付款处理器服务器只是为了检查特定订单的状态，这不应该是标准做法。"

      order_websocket:
        title: "订单websocket"
        paragraph1: "跟踪订单状态的另一种方法是连续连接到其各自的websocket。 事实上，这是您的客户重定向到的付款页面。 但是，您可能会决定不要使用“机密设备支付”页面。 也许您会想向您的客户展示您自己的自定义付款页面，这些页面将在您自己的网站上。 或者即使您使用标准付款页面，您的后端软件仍可能需要连接到订单的Websocket而不是等待回调请求。"
        paragraph2: "要连接到Websocket，您应该使用以下URL："
        paragraph3: "其中1是您的订单ID。 当订单状态更改时，Websocket将返回您在json中订购数据，与手动响应常规http请求检查订单状态时将返回的完全相同的数据。"

      order_cancel:
        title: "取消订单"
        paragraph1: "如果用户取消他的儲值，最好取消联系我们。"
        paragraph2: "可以通过发送签名请求来取消订单："
        paragraph3: "或者您可以使用straight-server-kit发送相同的请求"

      receive_last_keychain:
        title: "为网关接收last_keychain_id"
        paragraph1: "您可以通过以下请求获取特定网关的最后一个keychain id："
        paragraph2: "然后你会得到："

    developer_api:
      title: "开发者API"
      basic:
        title: "原理"
        paragraph1: "API基于JSONAPI（版本1.0）实现。"
        paragraph2: "Versioninig通过HTTP头Accept-Version完成。 可能没有设置版本，最后将被使用。"
        paragraph3: "为了使用Developer API，您应该先启用它并获得一个秘密密钥。 为此，请转到帐户部分，选中“启用开发人员API”，然后单击“保存更改”按钮。"
        paragraph4: "对API的每个请求都使用了这里描述的方法。"
        paragraph4_a: "这里"
        paragraph5: "您可以在您的帐户页面上生成您的密钥。 在页面底部检查“再生API秘密”复选框，输入您当前的密码，然后单击“保存更改”按钮 - 将为您生成API密钥。 请不要忘记把它写在某个地方。 如果您丢失了API密钥，则需要重新生成密钥。 在这个旧钥匙不再工作之后。"
        paragraph6: "在返回的对象的errors属性下返回所有错误，该属性的值作为错误数组。 如果您发送的请求中有错误，它将返回以下内容："     
        paragraph7: "如果有验证错误，响应可能如下所示："
        paragraph_title1: "验证"
        paragraph_title2: "错误"
      gateway:
        title: "网关"
        paragraph1: "使用Skyluster的开发人员API，可以创建，更新或获取一个列表（或一个）网关。"
        paragraph2: "要创建网关，您需要使用以下主体向/ api / gateway进行POST请求："
        paragraph3: "必填字段："
        paragraph4: "可选字段："
        paragraph5: "示例："
        paragraph6: "对此请求的响应应该是以下对象："
        paragraph7: "此外，它返回一个秘密密钥。 状态码为：201"
        paragraph8: "要更新网关，您需要使用以下机构对/ api / gateway进行PATCH请求："
        paragraph9: "其中id是要更改的网关的ID。 您可以在属性键下列出要更改的字段。 其他领域不会改变。"
        paragraph10: "要获取有关特定网关的信息，您需要创建GET请求/ api / gateway / {gateway_id}。"
        paragraph12: "结果应该是："
        paragraph13: "要获取所有网关的列表，您需要使用空的Body向/ api /网关发出GET请求。"
        paragraph14: "对此请求的响应应该是以下对象："
        paragraph15: "默认情况下，返回的列表限制为25条记录。 如果您想要更多，您需要发送分页部分中描述的查询参数。"
        paragraph16: "该策略是基于游标的。 可以将以下选项作为查询参数传递："
        paragraph17: "结果JSON将包含一个带有分页信息的meta属性："
        paragraph18: "示例:"
        paragraph19: "这将显示前5个网关。"
        paragraph20: "如果旧秘密被破坏或丢失，可以重新生成一个新的秘密。"
        paragraph21: "GET请求地址：api / gateway / {gateways_id} / regenerate_secret"
        paragraph22: "生成的JSON将如下所示："
        ul:
          li1: "网关的名字"
          li2: "从钱包导出的公钥(xpub)，用于接收比特币。"
          li3: "需要确认交易的区块数，用来确认交易是否成功。"
          li4: "订单需要等待支付的时间，值要介于0和1800之间。"
          li5: "用于显示订单金额的默认货币单位。"
          li6: "如果网关是Active状态，可以生成新的订单。默认值是True。"
          li7: "如何用提供的xpub来生成每个新地址（请查看BIP32文档）。"
          li8: "回调的URL，我们的服务器会向这个地址发送一个回调请求来通知所有订单状态的变更。"
          li9: "这是一个URL，用户支付完成后会自动跳转到这个地址。"
          li10: "是否开启用户支付完成后的自动重定向功能。默认值是false。"
          li11: "测试网络的公钥。用于test_mode是enabled的情况。"
          li12: "是否激活测试网络模式。默认值是false。"
          li13: "把给出的金额转化为指定的货币，可用的值有：BTC，USD，CNY，PESO。"
          li14: "汇率提供商。默认是：火币网，Okcoin，比特比中国。"
          li15: "是否发送新的支付提醒到用户邮箱。布尔型，默认值是false。"
          li16: "使用何种语言的消息提醒。目前只支持中文和英文。"
          li17: "用户点击取消订单后会跳转到该地址。"
        paragraph_title1: "创建网关"
        paragraph_title2: "更新网关"
        paragraph_title3: "获取特定网关的全部信息"
        paragraph_title4: "获取网关列表"
        paragraph_title5: "分页"
        paragraph_title6: "重新生成私钥"

      address_providers:
        title: "地址提供商"
        url_structure: "URL结构"
        parameters: "参数(*必填)"
        returns: "返回结果"
        example_request: "请求示例"

        list:
          title: "列表"
          paragraph1: "返回地址提供商的哈希列表。数组中的每个元素都包含地址提供商的ID和它的类型（例如：'address_provider_cashila'）。"

        cashila:
          title: "Cashila"
          login: 
            title: "登录"
            paragraph1: "通过向已有cashila账户提供资格证书来创建Cashila地址提供商。 必须提供以下信息：email/password 或 token/secret."

          withdraw:
            title: "提现"

          legal_entity: 
            title: "法人"

          individual_entity:
            title: "个体"


