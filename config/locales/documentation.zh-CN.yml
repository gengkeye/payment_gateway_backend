zh-CN:
  documentation:
    title: '开发者文档'
    introduction:
      title: "简介"
      paragraph1: "本文档主要的面向是希望将比特币支付处理集成到其在线商店或网站中的开发人员。如果您不是开发人员，但仍希望在您的网站上接受Bitcoin，则可以使用我们的分步指南创建一个简单的付款小插件。"
      paragraph2: "根据行业标准处理付款，如果您曾经处理过任何支付网关（不一定是Bitcoin），您应该快速了解一切如何正常工作以及该做什么对于那些从未从事付款处理的人员，我们将会解释每一个细节，并展示代码示例。"
      paragraph3: "Skyluster使用开源软件构建直向和直向服务器。您可以需要检查直向服务器的文档，以便更好地了解底层机制，但不是必需的。在直向服务器文档中提到的许多事情也在当前文档中提到。"
    overview_payment_process:
      title: '支付网关概述'
      paragraph1: "本节介绍有关付款处理的一些基本信息，并介绍将在以下部分中使用的术语。这里描述的一些事情对于所有支付处理器是常见的，而其他的可能不是。阅读本节后，您应该对Skyluster如何运作有一个很好的了解，并且可以继续下一节。"
      paragraph2: "支付网关用于处理您的付款 - 例如收取信用卡，然后在付款完成后将其报告回您的平台或网上商店。当用户点击您网站上的“付款”时，您将其重定向到付款处理器网站上的特殊付款页面，以便他们输入信用卡信息并付款。然后，当他们完成（或取消）付款时，支付处理器可以通过回调（有时称为webhook）让您的网站知道，并通过向您的网站发出http请求来传输关于付款的信息。那么您的网站有义务接收该信息并处理它。"
      paragraph3: "例如，假设您有一个名为worldsbestshoes.com的网站，通过信用卡付款处理器VeryPay.com接受付款。用户选择他的鞋子，将其添加到网站上的\"购物车\"，然后点击“完成购买”。在这一点上，你把他重定向到："
      paragraph4: "在那里，用户看到可以输入他的信用卡信息的表单。一旦他完成输入，他点击“付款”。一旦他这样做，VeryPay连接到他的信用卡公司的API，并试图收取卡。如果操作成功，它将用户重定向回您的网站（或向他显示将手动重定向到他的按钮），并发出回调（webhook）到:"
      paragraph5: "它通过POST参数发送所有关于付款的信息。如果付款失败，它可以让客户知道，并且还会在您的网站上发回同一个网址的回拨，但这次付款信息包含有关付款失败的信息。"
      paragraph6: "然后，您的网站会收到付款信息，根据是否可行，决定要做什么。如果付款通过，它将自己的数据库中的订单标记为已付款，然后您的运输部门可以开始包装鞋子。或者它可能会将其标记为“付款失败”，在这种情况下，您可能希望为客户提供使用其他信用卡再次尝试的选项。"
      paragraph7: "所描述的过程几乎与比特币付款相同。唯一的区别是，客户不需要提供任何敏感信息，如信用卡号码。相反，在付款页面上，他看到一个比特币地址（都是写入和作为二维码），然后可以使用他的钱包向该地址汇款。然后，付款处理器的工作是检测到付款，通知商家，并将客户重定向到平台站点。这正是Skyluster所做的。"
      paragraph8: "重要的问题是：付款时，钱在哪里？传统上，使用信用卡付款处理器，这笔钱首先从客户的银行帐户转到支付处理商的银行帐户，然后才转到商家。该系统的问题是付款处理器必须代表许多不同的商家接受和暂时存储货币，并且非常有信心保护该货币的能力。另一方面，商家必须愿意相信付款处理器。幸运的是，使用比特币，您可以解除货币存储和付款处理。使用BIP32，Skyluster可以从您从Bitcoin钱包（机密或Electrum）获得的每个付款发票上的公钥生成一个新地址。这样一来，客户支付的钱总是直接从客户的钱包进入商家的钱包，而支付处理器只是看着區块链，并检查该特定地址是否接收到比特币。商家不必相信他们的付款处理器，并且不会冒失去代表他们所持有的资金的风险，商家处理器不必担心与安全存储货币和客户数据相关的成本。"
      paragraph9: "因此，最好将“skyluster”视为付款通知系统而不是支付处理器。我们只看着这块块，我们实际上并不拥有任何人的钱。"
      paragraph10: "接下来的部分将详细说明如何将支付处理集成到您的网站或应用程序中。但是，首先熟悉将要使用的术语是一个好主意。"
      paragraph_title1: "为什么需要付款处理器？"
      paragraph_title2: "付款处理器通常如何工作？"
      paragraph_title3: "比特币支付处理如何不同？"
      paragraph_title4: "处理钱"
      paragraph_title5: "术语"
      li:
        strong1: "付款处理器"
        strong2: "网关"
        strong3: "订单"
        strong4: "回调"
        description1: "是一种专门的软件或服务，集成到您的网站，并在付款时通知它。对于比特币支付处理，skyluster负责汇率转换，各种比特币面额，生成新的比特币地址以及监控支付方式。请注意，有时支付处理器也称为支付网关。这些术语是同义词，但是在我们的术语中的一个门户将具有稍微更具体的含义。"
        description2: "是在skyluster中创建的一个实例，用于处理特定商店的所有付款。例如，您作为商家可能有两家网上商店。然后，您将在商戶管理面板中创建两个网关，并将其用于各自的网站。" 
        description3: "每次客户决定付款时都会创建一个订单。订单是一个数据集，其中包含诸如要支付的金额，付款将被发送的比特币地址等信息，以及许多其他信息。每个订单都存储在我们的数据库中，并与特定的网关和商家相关联。订单也有可能改变的状态。例如，当相关联的比特币地址接收到正确的数量时，设置“付费”状态。" 
        description4: "是一个http请求，只要订单更改其状态，就由付款处理器发出。每个网关允许您设置发出此请求的URL。您必须编程您的网站，以便它可以处理此请求，提取必要的信息，并正确使用它。" 
    create_gateway:
      title: "创建一个网关"
      paragraph1: "The first thing you will want to do after you sign up (and read the docs, of course) is to create a new <i>gateway</i>. Gateways are entities that create orders and process payments for a particular store. So, if you only have one online store, you will need to create one gateway."
      paragraph2: "To create a gateway, simply go to this page and fill out the form. Almost all of the fields are optional, and are explained below (required fields are marked with an asterisk *)."
      paragraph3: "*Name is what your customers will see at the top of the payment page when they try to make a purchase. It is also the name of the gateway that you see as a merchant in the admin panel. While it does not affect anything in particular, it's a good idea to put something meaningful in there.
      Confirmations required should typically be set to 0, unless you expect large payment amounts. In Bitcoin, each transaction is considered completely settled only when you have 6 confirmations (which may take about an hour). However, you can still assume with a degree of certainty that the payment will get processed and settled in one hour as soon as the transaction has been broadcasted to the Bitcoin network. You generally don't want your customers to wait, thus the current industry standard is to accept transactions with 0 confirmations. That way, as soon as your customer sends money from his wallet, we can detect that transaction and redirect him back to your website."
      paragraph4: "BIP32 pubkey is the most important of the fields, and looks similar to this (beginning with xpub):"
      paragraph5: "It is based on Bitcoin BIP32 standard, and is derived from your wallet's private key. Mycelium Gear uses it to generate new address for each new order. Not all wallets support BIP32, but two of the most popular ones — Mycelium and Electrum."
      paragraph6: "Order expiration period is the period of time during which a customer has to pay for the order. If he does not pay in time, the order is considered expired. The default is 900 seconds (15 minutes) which is an industry standard."
      paragraph7: "After payment redirect url is used to return the customer back to your website after a successful purchase. This could be a page specific to the order, or to their account."
      paragraph8: "Whenauto redirectis checked, all users whose payments were successful are automatically redirected to the After payment redirect url."
      paragraph9: "Active flag simply means that this gateway is currently ready to process payments. If you need to temporarily stop accepting payments, you can always come back to that form (edit the existing gateway) and uncheck that checkbox."
      paragraph10: "Currency conversion options section allows you to choose what currency your order prices are displayed in, and which bitcoin price source to use to convert that value into the appropriate amount of bitcoins. The default setting is USD and you probably want to leave it that way, since the Bitcoin exchange rate can fluctuate substantially, making it inconvenient to set prices in BTC. The exchange rate provider fields allow you to choose which sources to use for the current exchange rate. Exchange rates are checked in the order set here, with subsequent providers only checked if the previous provider is unavailable for some reason."
      paragraph11: "Additional info about the merchant block is completely optional, but we would prefer if merchants fill it, since this will help us provide our customers with better service. This information is not used for compliance — Mycelium Gear does not handle any money (just watches the transactions on the blockchain) and is not subject to AML/KYC — and we do not share this information with anyone."
      paragraph12: "After you click the 'Create gateway' button below the form, if all fields are valid, you will be redirected to the gateway info page and will be presented with a gateway secret. <strong>You must write it down</strong> as it will not appear again anywhere. If you ever lose that secret, you will need to come back to that form (edit the gateway) and check the 'Regenerate secret' checkbox; however this will invalidate your previous secret and any of your online stores that were using it will have to update it to the new one."
      paragraph13: "The secret key is essentially a signature that all your requests to the gateway are signed with, which the gateway uses to verify that it's you who is talking to it, and not some impostor. We will explain how to use this secret key in detail in the next section."
      paragraph_title1: "Filling the form"
      paragraph_title2: "Getting the gateway secret"
    api:
      title: "API"
      signed_request:
        title: "请求加密"
        paragraph1: "大部分API请求都需要通过签名来阻止未授权的访问。签名是一个X-Signature HTTP请求头部，包含88个字符："
        paragraph2: "注解："
        paragraph3: "Ruby用户可以使用gem straight-server-kit来签名。"
        paragraph4: "There is a tiny chance that request will fail with 'X-Nonce is invalid' error because of simultaneous signed request with a greater nonce. This may be mitigated by repeating request with the updated nonce and signature."
        paragraph5: "Some languages like JavaScript have poor support for binary string, so hexdigest signature is also valid"
        paragraph6: "注解："
        paragraph7: "Example 1:"
        paragraph8: "Example 2:"
        paragraph9: "Example 3:"
        ul:
          li1: "REQUEST_METHOD: 'GET', 'POST', etc."
          li2: "REQUEST_URI: “/full/path/with?arguments&amp;and#fragment”, without hostname"
          li3: "REQUEST_BODY: final request body string with JSON or blank string"
          li4: "X-Nonce: HTTP header with an integer which must be incremented with each request (protects from replay attack), for example (Time.now.to_f * 1000).to_i"
          li5: "SHA512: binary SHA-2, 512 bits"
          li6: "HMAC-SHA512: binary HMAC with SHA512"
          li7: "GATEWAY_SECRET: key for HMAC"
          li8: "Base64StrictEncode: Base64 encoding according to RFC 4648"
          li9: "SHA512: hex-encoded SHA-2, 512 bits"
          li10: "HMAC-SHA512: hex-encoded HMAC with SHA512"
      create_orders:
        title: "创建订单"
        paragraph1: "Creating an order is the first step towards accepting a payment. Generally, you want to create an order AFTER your customer clicks 'Complete purchase' or a similar button in your online store. After you create an order using our RESTFUL API, you can redirect the user to the Mycelium Gear payment page associated with this order."
        paragraph2: "To create an order, you should issue a signed POST request to https://gateway.gear.mycelium.com/gateways/:gateway_id/orders with at least one param — amount — it determines the amount to be paid for this order. The amount should be in the currency you have previously set for the gateway. If the gateway currency is BTC, then the amount is normally in satoshis. So, the request may look like this:"
        paragraph3: "You can get the api_gateway_id value from your gateway's info in the admin panel."
        paragraph4: "Keychain id is used to generate an address for the next order. It can be any integer &gt; 0, but it's better if it is a consecutive integer, so keep track of your order ids in your application. With the keychain id, the request will look like this:"
        paragraph5: "You may want to send some additional data with the transaction that will later be returned to you, unchanged, in the callback. This is useful if you wish to identify which record in your DB is associated with which order by using something other than order_id."
        paragraph6: "For example, suppose you have a Purchase model in your Rails app. You then might want to create a purchase and send its id in the <code>callback_data</code> param:"
        paragraph7: "Later on, when a callback request is issued, this <code>callback_data</code> param will be returned back with it and you'll be able to find that purchase in your DB."
        paragraph8: "In response to the request above, you will receive the following json from Mycelium Gear:"
        paragraph9: "With this information, you can either manually display the payment address to the customer on your website (so he doesn't even have to leave your site), or you can redirect him to the Mycelium Gear payment page using the payment_id. The payment page url for redirection will then be:"
        paragraph10: "keychain_id is used to derive the next address from your BIP32 pubkey. If you try to create orders with the same keychain_id they will also have the same address, which is, as you can imagine, not a very good idea. However it is allowed and there's a good reason for that."
        paragraph11: "Wallets that support BIP32 pubkeys will only do a forward address lookup for a limited number of addreses. For example, if you have 20 expired, unpaid orders and someone sends you money to the address of the 21-st order, your wallet may not see that. Thus, it is important to ensure that there are no more than 20 expired orders in a row."
        paragraph12: "If you have 20 orders in a row and try to create another one, Gear will see that and will automatically reuse the keychain_id (and consequently, the address too) of the 20-th order. It will also set the 21-st order's reused field to the value of 1. You will see it marked as reused in the admin panel too."
        paragraph13: "CAUTION: It is very important to make sure that you don't accidentally provide keychain_id that is too far away from the last used one. For example, if the gateway's <code>last_keychain_id</code> is <code>10</code>, do not use <code>35</code> for the next order, use <code>11</code>. <code>last_keychain_id</code> is always returned with other info when you create or check order status. Make sure you always track <code>last_keychain_id</code> in your application - it is normally returned to you in the json with the other order info when you create or check orders."
        paragraph14: "Suppose you have a Rails controller with an action called complete_purchase which handles customer requests when they hit the 'Complete purchase' button on your site. This is what code for it may look like:"
        paragraph_title1: "The request and the signature"
        paragraph_title2: "Sending additional data"
        paragraph_title3: "The response"
        paragraph_title4: "Address reuse and keychain_id"
        paragraph_title5: "Code example"
      receive_order_callback:
        title: "接收订单状态变更回调"
        paragraph1: "Whenever an order status changes, Mycelium Gear issues a GET http request to the url specified in the gateway&#39;s callback field (if you filled it) or in the order&#39;s <code>callback_url</code> param. This way it lets your site know that the payment was either successful or has failed for some reason. This http request is also sometimes called a webhook, although we prefer not to use that term."
        paragraph2: "Important information is passed in this http request as url params. Here&#39;s what a typical callback may look like:"
        paragraph3: "Also, request will have special header:"
        paragraph4: "The following list explains in detail the information and parameters in the GET callback request:"
        paragraph5: "It&#39;s generated in the same way as a signature for signed API requests, except that it uses blank Nonce and Body."
        paragraph6: "In Ruby, callback signature can be verified using <code>straight-server-kit</code> gem."
        paragraph7: "Details of signature verification."
        paragraph8: "JavaScript version using"
        paragraph_title1: "Callback signature"
        ul:
          li1: "An internal id of the order. This is how you can find the corresponding purchase record in your database. It is also used for the signature."
          li2: "This is the amount in the gateway&#39;s currency that was supposed to be paid"
          li3: "This is the amount in btc that was supposed to be paid"
          li4: "This is the amount in btc that has been paid"
          li5: "Returns a numerical value which can be either of the following:"
          li6: "unconfirmed; transaction was received, but does not have enough confirmations yet"
          li7: "paid in full"
          li8: "underpaid; not enough money received"
          li9: "overpaid; too much has been received"
          li10: "expired; customer did not pay in time"
          li11: "canceled; customer has canceled the order"
          li12: "The Bitcoin address to which a transaction was supposed to be made"
          li13: "If the status is 1,2,3 or 4, this will contain JSON array with the Bitcoin transaction IDs"
          li14: "This contains any additional data that was sent along with the transaction while creating the order. For example, if you sent &quot;hello world&quot; as data in the request that created that order, you will also get the same string back with a callback — as the value for the callback_data key within the returned json."
          li15: " This is the most important piece of information in regards to security. Keep in mind that anyone can make a request to that callback url of yours and basically fool your website into believing that a certain order was paid. To avoid that, Mycelium Gear uses signatures to sign a callback request, so that you can verify it came from Mycelium Gear and not somebody else. This is explained in detail below."

      check_order_status:
        title: "手动查询订单状态"
        paragraph1: "Although being notified through a callback is the standard way of letting your website know that an order status has changed, sometimes it may not be enough. For example, your website may be down and may not be able to process the callback at the time it was issued. Even though Mycelium Gear will keep attempting to issue new callback requests to try and reach your website, it will only keep doing it for an hour, after which it will quit."
        paragraph2: "Thus, it is important to have another reliable method of checking order statuses. To check the current status of an order, issue the following signed GET request:"
        paragraph3: "where <code>:api_gateway_id</code> is the API id of your gateway, which you can look up on its info page; and <code>:payment_id</code> is the way you identify your order (it was returned to you initially when you created the order). The response will return a json similar to what a callback might have passed to you via params:"
        paragraph4: "You should use this manual check only if you suspect that you may have missed a callback. It should not be standard practice to keep querying the payment processor server every few seconds just to check the status of a particular order."

      order_websocket:
        title: "订单websocket"
        paragraph1: "Another way to track order status is to be continually connected to its respective websocket. In fact, this is what the payment page that your customer is redirected to does. However, you may decide you don&#39;t want to use the Mycelium Gear payment page. Perhaps you would want to present your customer with your own customized payment page that will be on your own site. Or even if you are using a standard payment page, your backend software may still want to connect to the order&#39;s websocket instead of waiting for a callback request."
        paragraph2: "To connect to the websocket, you should use the following URL:"
        paragraph3: "where 1 is your order id. When order status changes, the websocket returns you order data in json, exactly the same data that would be returned as a response to a regular http request checking order status manually."

      order_cancel:
        title: "取消订单"
        paragraph1: "If user cancels his purchase, it&#39;s better to cancel the Mycelium Gear order as well."
        paragraph2: "Order can be canceled by sending a signed request:"
        paragraph3: "or you can send the same request by using straight-server-kit:"

      receive_last_keychain:
        title: "为网关接收last_keychain_id"
        paragraph1: "You can get last keychain id for a specific gateway with the following request:"
        paragraph2: "Then you&#39;ll get something like this:"

    developer_api:
      title: "开发者API"
      basic:
        title: "原理"
        paragraph1: "The API is based on JSONAPI (version 1.0) implementation."
        paragraph2: "Versioninig is done through HTTP header Accept-Version. It&#39;s possible to not set version, then last will be used. "
        paragraph3: "In order to use Developer API you should first enable it and get a Secret key. To do so, proceed to account section, check &quot;Enable Developers API&quot; and click &quot;Save changes&quot; button."
        paragraph4: "Each request to the API is signed usging the method described"
        paragraph4_a: "here"
        paragraph5: "You can generate your <strong>Secret key</strong> on your account page. At the bottom of the page check &quot;Regenerate API Secret&quot; checkbox, enter your current password and click &quot;Save changes&quot; button - API Secret key will be generated for you. Please, don&#39;t forget to write it down somewhere. If you lost API Secret key, you will need to regenerate it. After this old key will no longer work."
        paragraph6: "All errors are returned under the <em>errors</em> property in the returned object, the value of that property is as an array of errors. If there are errors in the request you&#39;ve sent, it will return the following:"     
        paragraph_title1: "Authentication"
        paragraph_title2: "Errors"
      gateway:
        title: "网关"
        paragraph1: "With Gear&#39;s developer API, it is possible to create, update or get a list (or one) of gateways."
        paragraph2: "To create a gateway, you need to make a POST request to /api/gateways with the following body:"
        paragraph3: "Required fields:"
        paragraph4: "Optional fields:"
        paragraph5: "Example:"
        paragraph6: "A response to this request should be the following object:"
        paragraph7: "Additionally it returns a <em>secret</em> key. Status code is: <strong>201</strong>"
        paragraph8: "To update a gateway, you need to make a <strong>PATCH</strong> request to <code>/api/gateways</code> with the following body:"
        paragraph9: "where <em>id</em> is an ID of a gateway you want to change. You can list fields you wish to change under the <em>attributes</em> key. Others fields will not change."
        paragraph10: "To get information about a specific gateway, you need to make a <strong>GET</strong> request <code>/api/gateways/{gateway_id}</code>."
        paragraph12: "In result a response will be:"
        paragraph13: "To fetch a list of all gateways you need to make a <strong>GET</strong> request to <code>/api/gateways</code> with an empty body."
        paragraph14: "A response to this request should be the following object:"
        paragraph15: "By default the returned list is limited to 25 records. If you want more, you&#39;ll need to send a query parameter described in <em>Pagination</em> section."
        paragraph16: "The strategy is cursor-based. The following options may be passed as query parameters:"
        paragraph17: "The resulting JSON will contain a <em>meta</em> property with the pagination info:"
        paragraph18: "Example:"
        paragraph19: "This will show first 5 gateways."
        paragraph20: "If old secret was compromised or lost it is possible to regenerate a new one."
        paragraph21: "<strong>GET</strong> request to address: <code>api/gateways/{gateways_id}/regenerate_secret</code>"
        paragraph22: "The resulting JSON will be like:"
        ul:
          li1: "Name of your gateway"
          li1: "Public key (xpub) exported from the wallet to which you will receive Bitcoins"
          li1: "Number of required confirmations to consider transaction successful"
          li1: "How long the order will be waiting for a payment (in milliseconds). Should be between 0 and 1800"
          li1: "Default currency to display order amounts in"
          li1: "If a gateway is active (can generate new orders). Default: <em>true</em>"
          li1: "How we derive each new address from the provided xpub (see BIP32 documentation)"
          li1: "A callback url is where our server will report all order status changes by performing a callback request"
          li1: "Is a URL to which users are redirected after they made a payment"
          li1: "Automatically redirect user after payment. Boolean. Default: <em>false</em>"
          li1: "Testnet public key. Used if <em>test_mode</em> is enabled"
          li1: "Activate or deactivate testnet mode. Default: <em>false</em>Convert given amount in to specific currency. Possible: &quot;BTC&quot;, &quot;USD&quot;, &quot;EUR&quot;. Default: <em>&quot;BTC&quot;</em>"
          li1: "Convert given amount in to specific currency. Possible: &quot;BTC&quot;, &quot;USD&quot;, &quot;EUR&quot;. Default: <em>&quot;BTC&quot;</em>"
          li1: "Where we get exchange rates. Array. Default: <em>[&quot;Bitstamp&quot;, &quot;Btce&quot;, &quot;Kraken&quot;]</em>"
          li1: "Send notifications about new payments to client email. Boolean. Default: <em>false</em>"
          li1: "Locale for all messages. Only english aviable on the current moment."
          li1: "Is a URL to which users are taken if they click Cancel in the payment screen."

      address_providers:
        title: "地址提供商"
        url_structure: "URL结构"
        parameters: "参数(*必填)"
        returns: "返回结果"
        example_request: "请求示例"

        list:
          title: "列表"
          paragraph1: "返回地址提供商的哈希列表。数组中的每个元素都包含地址提供商的ID和它的类型（例如：'address_provider_cashila'）。"

        cashila:
          title: "Cashila"
          login: 
            title: "登录"
            paragraph1: "通过向已有cashila账户提供资格证书来创建Cashila地址提供商。 必须提供以下信息：email/password 或 token/secret."

          withdraw:
            title: "提现"

          legal_entity: 
            title: "法人"

          individual_entity:
            title: "个体"


